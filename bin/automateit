#!/usr/bin/env ruby

# XXX What can go wrong with this loading approach?
libdir = File.expand_path(File.join(File.dirname(__FILE__), "..", "lib"))
if File.directory?(libdir) and File.exists?(File.join(libdir, "automateit.rb"))
  $LOAD_PATH.unshift(libdir)
end

require 'rubygems'
require 'logger'
require 'optparse'
require 'automateit'

include AutomateIt::Constants

OptionParser.new do |parser|
  PROG = File.basename($0)
  opts = {}
  parser.banner = <<EOB
#{PROG} - tool for automating the setup and maintenance of Unix-like systems

Usage: #{PROG} [options] [recipe]

Examples:
  # Start an interactive shell session
  #{PROG}

  # Execute a recipe
  #{PROG} myrecipe.rb

  # Preview what a recipe does using noop mode
  #{PROG} -n myrecipe.rb

  # Eval a string
  #{PROG} -e "puts tags.to_a.inspect"

Options:
EOB
  parser.on("-c", "--create PATH", "Create project at path") do |v|
    opts[:create] = v
  end

  parser.on("-p", "--project PATH", "Set project path") do |v|
    opts[:project] = v
  end

  parser.on("-n", "--noop", "Preview without executing commands") do |v|
    opts[:noop] = v
  end

  parser.on("-e", "--eval STRING", "Evaluate string") do |v|
    opts[:eval] = v
  end

  parser.on("-q", "--quiet", "Print only errors") do |v|
    opts[:verbosity] = Logger::ERROR
  end

  parser.on("-d", "--debug", "Print debugging information") do |v|
    opts[:verbosity] = Logger::DEBUG
  end

  parser.on("-v", "--version", "Display version") do |v|
    opts[:version] = v
  end

  parser.on("-T", "--trace", "Display raw exception traces") do |v|
    opts[:friendly_exceptions] = ! v
  end

  args = parser.parse!.dup

  if opts[:version]
    puts VERSION
    exit 0
  end

  # Clear ARGV so that IRB doesn't try to parse our options
  opts[:args] = args
  ARGV.clear

  opts[:recipe] = args.first unless args.empty?

  # Save vars because +run+ will delete opts
  argscopy = args.clone
  optscopy = opts.clone

  begin
    rv = AutomateIt::CLI.run(opts)
  rescue Exception => e
    msg = nil
    if opts[:friendly_exceptions] != false and e.is_a?(AutomateIt::Error)
      # Friendly message
      msg = PERROR+e.message
      msg << "\n\n"+PNOTE+"Use 'automateit --trace' to see complete backtrace"
    else
      # Raw backtrace
      puts PERROR+"AutomateIt error trace:"
      stack = e.backtrace.clone
      msg = "#{stack.shift}: #{e.message} (#{e.exception.class})}";
      for line in stack
        msg << "\n  "+line
      end
    end
    puts msg
    exit 1
  rescue SysExit => e
    # Don't display errors when exit gets called
  end
  if optscopy[:create] or optscopy[:eval] or argscopy.size > 0
    exit rv ? 0 :1
  else
    # CTRL-D ends the line prematurely, so add a newline
    puts
  end
end
