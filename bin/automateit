#!/usr/bin/env ruby

# XXX What can go wrong with this loading approach?
libdir = File.expand_path(File.join(File.dirname(__FILE__), "..", "lib"))
if File.directory?(libdir) and File.exists?(File.join(libdir, "automateit.rb"))
  $LOAD_PATH.unshift(libdir)
end

require 'rubygems'
require 'logger'
require 'optparse'
require 'automateit'

OptionParser.new do |parser|
  PROG = File.basename($0)
  opts = {}
  parser.banner = <<EOB
#{PROG} - tool for automating the setup and maintenance of UNIX-like systems

Usage: #{PROG} [options] [recipe]

Examples:
  # Start an interactive shell session
  #{PROG}

  # Execute a recipe
  #{PROG} myrecipe.rb

  # Preview what a recipe does using noop mode
  #{PROG} -n myrecipe.rb

  # Eval a string
  #{PROG} -e "puts tags.to_a.inspect"

Options:
EOB
  parser.on("-c", "--create PATH", "Create project at path") do |v|
    opts[:create] = v
  end

  parser.on("-p", "--project PATH", "Set project path") do |v|
    opts[:project] = v
  end

  parser.on("-n", "--noop", "Preview without executing commands") do |v|
    opts[:noop] = v
  end

  parser.on("-e", "--eval STRING", "Evaluate string") do |v|
    opts[:eval] = v
  end

  parser.on("-q", "--quiet", "Print only errors") do |v|
    opts[:verbosity] = Logger::ERROR
  end

  parser.on("-d", "--debug", "Print debugging information") do |v|
    opts[:verbosity] = Logger::DEBUG
  end

  args = parser.parse!.dup

  # Clear ARGV so that IRB doesn't try to parse our options
  opts[:args] = args
  ARGV.clear

  opts[:recipe] = args.first unless args.empty?

  exit AutomateIt::CLI.run(opts) ? 0 :1
end
